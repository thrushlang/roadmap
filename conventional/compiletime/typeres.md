<p align="center">
  <img src= "https://github.com/thrushlang/thrushc/blob/master/assets/thrushlang-v1.5.png" alt= "logo" style= "width: 2hv; height: 2hv;"> </img>
</p>

# Thrush Programming Language 

## Roadmap > Conventional Programming > Compile Time Code Execution > JIT Dynamic External Type Resolution

This article will briefly discuss how the JIT, together with Cbingen, generates external types for the resolution of external symbols and their subsequent invocation in the JIT.

### JIT Dynamic Types - Generation Type Symbol Resolution

This point is when the JIT begins compiling all the representations it is assigned, provided by the compiler's frontend. This stage maps dynamic symbols found through dynamic libraries provided by the compiler itself (C Runtime and the C Standard Library) or by the programmer via the command line.

This stage searches for each of the functions in all these library representations in the PIE-Dynamic model.

Once it finds them, it adds them to the JIT with the function represented in Rust in the LLVM C API as:

```rust
pub unsafe extern "C" fn LLVMAddGlobalMapping(
    EE: LLVMExecutionEngineRef,
    Global: LLVMValueRef,
    Addr: *mut c_void,
)
```

Just before the JIT generates the code, CBindgen comes into play. It takes the types generated by CBindgen (for example, libc) and generates the IR for each function for its use. These functions are placed in maps, which the JIT will then consult by name at compile time. Once the JIT finds the matching type, it will call the system in charge of generating the symbol.

A dynamic symbol can be obtained in a simple way from [libloading](https://crates.io/crates/libloading) crate in Rust, with the function:

```rust
pub unsafe fn get<T>(&self, symbol: &[u8]) -> Result<Symbol<T>, Error>
```
Once it finds the symbol, it obtains its memory address and passes it to the JIT so that it can integrate it into its global mappings.

Once the entrypoint has been identified, the entrypoint is called for dynamic execution in the JIT and its previous AOT compilation.

The entrypoint execution can be denoted by the LLVM-C API function in Rust:

```rust
pub unsafe extern "C" fn LLVMRunFunction(
    EE: LLVMExecutionEngineRef,
    F: LLVMValueRef,
    NumArgs: c_uint,
    Args: *mut LLVMGenericValueRef,
) -> LLVMGenericValueRef
```